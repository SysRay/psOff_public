#pragma once
#include "codes.h"
#include "utility/utility.h"

using unity_EXCEPTION_HANDLER = SYSV_ABI void (*)(int signum, void* ctx);

enum class SiCode : uint32_t {
  SI_NOINFO  = 0,       // No signal info besides si_signo.
  SI_USER    = 0x10001, // Signal sent by kill().
  SI_QUEUE   = 0x10002, // Signal sent by the sigqueue().
  SI_TIMER   = 0x10003, // Signal generated by expiration of a timer set by timer_settime().
  SI_ASYNCIO = 0x10004, // Signal generated by completion of an asynchronous I/O request.
  SI_MESGQ   = 0x10005, // Signal generated by arrival of a message on an empty message queue.
  SI_KERNEL  = 0x10006,
  SI_LWP     = 0x10007, // Signal sent by thr_kill
};

enum class SignalCode : int {
  sceSIGHUP,    // hangup
  sceSIGINT,    // interrupt
  sceSIGQUIT,   // quit
  sceSIGILL,    // illegal instr. (not reset when caught)
  sceSIGTRAP,   // trace trap (not reset when caught)
  sceSIGABRT,   // abort()
  sceSIGEMT,    // EMT instruction
  sceSIGFPE,    // floating point exception
  sceSIGKILL,   // kill (cannot be caught or ignored)
  sceSIGBUS,    // bus error
  sceSIGSEGV,   // segmentation violation
  sceSIGSYS,    // non-existent system call invoked
  sceSIGPIPE,   // write on a pipe with no one to read it
  sceSIGALRM,   // alarm clock
  sceSIGTERM,   // software termination signal from kill
  sceSIGURG,    // urgent condition on IO channel
  sceSIGSTOP,   // sendable stop signal not from tty
  sceSIGTSTP,   // stop signal from tty
  sceSIGCONT,   // continue a stopped process
  sceSIGCHLD,   // to parent on child stop or exit
  sceSIGTTIN,   // to readers pgrp upon background tty read
  sceSIGTTOU,   // like TTIN if (tp->t_local&LTOSTOP)
  sceSIGIO,     // input/output possible signal
  sceSIGXCPU,   // exceeded CPU time limit
  sceSIGXFSZ,   // exceeded file size limit
  sceSIGVTALRM, // virtual time alarm
  sceSIGPROF,   // profiling time alarm
  sceSIGWINCH,  // window size changes
  sceSIGINFO,   // information request
  sceSIGUSR1,   // user defined signal 1
  sceSIGUSR2,   // user defined signal 2
  sceSIGTHR     // reserved by thread library.
};

struct SigInfo {
  int32_t  si_signo  = 0;
  int32_t  si_errno  = 0;
  SiCode   si_code   = SiCode::SI_NOINFO;
  long     si_pid    = 0;
  int32_t  si_uid    = 0;
  int32_t  si_status = 0;
  void*    si_addr   = nullptr;
  uint32_t si_value  = 0;
  uint32_t _reason   = 0;
  uint32_t dummy[20] {0}; // todo: not sure how big struct is
};